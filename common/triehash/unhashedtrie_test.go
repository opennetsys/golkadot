package triehash

import (
	"fmt"
	"reflect"
	"testing"

	"github.com/opennetsys/go-substrate/common/stringutil"
)

func TestUnhashedTrie(t *testing.T) {
	for i, tt := range []struct {
		in  []*TriePair
		out []uint8
	}{
		{
			// a simple branch
			[]*TriePair{
				{K: []uint8{0xaa}, V: []uint8{0x10}},
				{K: []uint8{0xba}, V: []uint8{0x11}},
			},
			[]uint8{0xfe, 0x00, 0x0c, 0x10, 0x02, 0x0a, 0x04, 0x10, 0x10, 0x02, 0x0a, 0x04, 0x11},
		},
		{
			// an extension and branch
			[]*TriePair{
				{K: []uint8{0xaa}, V: []uint8{0x10}},
				{K: []uint8{0xab}, V: []uint8{0x11}},
			},
			hexToU8a("0x810a2cfe000c0c0104100c010411"),
		},
		{
			// extension and branch with value
			[]*TriePair{
				{K: []uint8{0xaa}, V: []uint8{0xa0}},
				{K: []uint8{0xaa, 0xaa}, V: []uint8{0xaa}},
				{K: []uint8{0xaa, 0xbb}, V: []uint8{0xab}},
			},
			[]uint8{0x82, 0xaa, 0x3c, 0xff, 0x00, 0x0c, 0x04, 0xa0, 0x10, 0x02, 0x0a, 0x04, 0xaa, 0x10, 0x02, 0x0b, 0x04, 0xab},
		},
		{
			// medium extension and branch with value
			[]*TriePair{
				{K: []uint8{0xaa}, V: []uint8{0xa0}},
				{K: []uint8{0xaa, 0xaa}, V: []uint8{0xaa}},
				{K: []uint8{0xaa, 0xbb}, V: []uint8{0xab}},
				{K: []uint8{0xbb}, V: []uint8{0xb0}},
			},
			[]uint8{0xfe, 0x00, 0x0c, 0x48, 0x81, 0x0a, 0x3c, 0xff, 0x00, 0x0c, 0x04, 0xa0, 0x10, 0x02, 0x0a, 0x04, 0xaa, 0x10, 0x02, 0x0b, 0x04, 0xab, 0x10, 0x02, 0x0b, 0x04, 0xb0},
		},
		{
			// bigger extension and branch with value
			[]*TriePair{
				{K: []uint8{0xaa}, V: []uint8{0xa0}},
				{K: []uint8{0xaa, 0xaa}, V: []uint8{0xaa}},
				{K: []uint8{0xaa, 0xbb}, V: []uint8{0xab}},
				{K: []uint8{0xbb}, V: []uint8{0xb0}},
				{K: []uint8{0xbb, 0xbb}, V: []uint8{0xbb}},
				{K: []uint8{0xbb, 0xcc}, V: []uint8{0xbc}},
			},
			[]uint8{0xfe, 0x00, 0x0c, 0x48, 0x81, 0x0a, 0x3c, 0xff, 0x00, 0x0c, 0x04, 0xa0, 0x10, 0x02, 0x0a, 0x04, 0xaa, 0x10, 0x02, 0x0b, 0x04, 0xab, 0x48, 0x81, 0x0b, 0x3c, 0xff, 0x00, 0x18, 0x04, 0xb0, 0x10, 0x02, 0x0b, 0x04, 0xbb, 0x10, 0x02, 0x0c, 0x04, 0xbc},
		},
		{
			// a single long leaf
			[]*TriePair{
				{K: []uint8{0xaa}, V: stringutil.ToUint8Slice("ABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABC")},
				{K: []uint8{0xba}, V: []uint8{0x11}},
			},
			[]uint8{0xfe, 0x00, 0x0c, 0x80, 0x0e, 0x26, 0xe9, 0x80, 0x0a, 0xc2, 0x7f, 0x56, 0x5c, 0x7e, 0x7c, 0xa7, 0x95, 0x16, 0x24, 0x78, 0x35, 0xea, 0x07, 0x6c, 0x5b, 0x62, 0x5f, 0x2d, 0x61, 0x00, 0x1a, 0x7b, 0xab, 0xad, 0xbf, 0x11, 0x10, 0x02, 0x0a, 0x04, 0x11},
		},
		{
			// two long leaves
			[]*TriePair{
				{K: []uint8{0xaa}, V: stringutil.ToUint8Slice("ABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABC")},
				{K: []uint8{0xba}, V: stringutil.ToUint8Slice("ABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABC")},
			},
			[]uint8{0xfe, 0x00, 0x0c, 0x80, 0x0e, 0x26, 0xe9, 0x80, 0x0a, 0xc2, 0x7f, 0x56, 0x5c, 0x7e, 0x7c, 0xa7, 0x95, 0x16, 0x24, 0x78, 0x35, 0xea, 0x07, 0x6c, 0x5b, 0x62, 0x5f, 0x2d, 0x61, 0x00, 0x1a, 0x7b, 0xab, 0xad, 0xbf, 0x11, 0x80, 0x0e, 0x26, 0xe9, 0x80, 0x0a, 0xc2, 0x7f, 0x56, 0x5c, 0x7e, 0x7c, 0xa7, 0x95, 0x16, 0x24, 0x78, 0x35, 0xea, 0x07, 0x6c, 0x5b, 0x62, 0x5f, 0x2d, 0x61, 0x00, 0x1a, 0x7b, 0xab, 0xad, 0xbf, 0x11},
		},
		{
			// empty into [0]
			[]*TriePair{},
			[]uint8{0},
		},
		{
			// a single tuple
			[]*TriePair{
				{K: []uint8{0xaa}, V: []uint8{0xbb}},
			},
			[]uint8{
				0x03,   // leaf (0x01) with (+) key of 2 nibbles (0x02)
				0xaa,   // key data
				1 << 2, // length of value in bytes as Compact
				0xbb,   // value data
			},
		},
		{
			// a single tuple (prepare for next)
			[]*TriePair{
				{K: []uint8{0x48, 0x19}, V: []uint8{0xfe}},
			},
			[]uint8{0x05, 0x48, 0x19, 0x04, 0xfe},
		},
		{
			// two disjointed tuple keys
			[]*TriePair{
				{K: []uint8{0x48, 0x19}, V: []uint8{0xfe}},
				{K: []uint8{0x13, 0x14}, V: []uint8{0xff}},
			},
			[]uint8{
				0xfe,      // branch, no value
				0x12,      // slots 1 & 4 are taken from 0-7
				0x00,      // no slots from 8-15
				0x05 << 2, // first slot: LEAF, 5 bytes long.
				0x04,      // leaf with 3 nibbles
				0x03,      // first nibble
				0x14,      // second & third nibble
				0x01 << 2, // 1 byte data
				0xff,      // value data
				0x05 << 2, // second slot: LEAF, 5 bytes long.
				0x04,      // leaf with 3 nibbles
				0x08,      // first nibble
				0x19,      // second & third nibble
				0x01 << 2, // 1 byte data
				0xfe,      // data
			},
		},
		{
			// substrate (paritial 0)
			[]*TriePair{
				{
					K: hexToU8a("0x3a617574683a00000000"),
					V: hexToU8a("0x82c39b31a2b79a90f8e66e7a77fdb85a4ed5517f2ae39f6a80565e8ecae85cf5"),
				},
				{
					K: hexToU8a("0x7935e46f94f24b82716c0142e2271de9"),
					V: hexToU8a("0x0087000000000000"),
				},
				{
					K: hexToU8a("0x27b3872d47181b4a2dc15f0da43e7026"),
					V: hexToU8a("0xe803000000000000"),
				},
			},
			hexToU8a("0xfe8c00682007b3872d47181b4a2dc15f0da43e702620e80300000000000080170d322ac49d8708f151346c68d9e58452d83a9d3b710e1ead35eb3269ab235368200935e46f94f24b82716c0142e2271de9200087000000000000"),
		},
	} {
		t.Run(fmt.Sprintf("%v", i), func(t *testing.T) {
			result := UnhashedTrie(tt.in)
			if !reflect.DeepEqual(result, tt.out) {
				t.Errorf("want %v; got %v", tt.out, result)
			}
		})
	}
}
